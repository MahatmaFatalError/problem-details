= Problem Details
:toc:

image::https://api.bintray.com/packages/t1/javaee-helpers/problem-details/images/download.svg[link="https://bintray.com/t1/javaee-helpers/problem-details/_latestVersion"]

Maps standard and custom exceptions to http response bodies containing problem details as specified in https://tools.ietf.org/html/rfc7807[RFC-7807].

On the server side, you can simply throw an exception, and most things will just work. Or use annotations on the exception to override the default behavior.

On the client side, you can register an extension, so a type-safe exception is thrown for your code to catch.

== Server Side Examples

=== Default Mapping

To produce a problem detail body, simply throw an exception, e.g.:

[source,java]
---------------------------------------------------------------
throw new NotFoundException("There is no article " + articleId);
---------------------------------------------------------------

Will result in an exception body similar to this:

[source,json]
---------------------------------------------------------------
{
  "type": "urn:problem-type:not-found",
  "title": "Not Found",
  "status": 404,
  "detail": "There is no article 862353",
  "instance": "urn:uuid:d294b32b-9dda-4292-b51f-35f65b4bf64d"
}
---------------------------------------------------------------

`type`:: The default is a URN derived from the type name of the exception by converting camel case to kebap case.
`title`:: The default is derived from the type name of the exception by converting camel case to separate words.
`status`:: The default is `500` except for an `IllegalArgumentException`, which gets mapped to 400, and the JAX-RS exceptions, which get mapped to their responsive status code.
`detail`:: The default is the message of the exception. There won't be a `detail` field, if the message of the exception is null.
`instance`:: The default is a random UUID URN.

If the first requested type (in an `Accept` header) is `application/xml`, the body will be the xml equivalent of this json document.

=== Default Logging

The stack trace is explicitly _never_ part of the body, as it must be considered sensitive information. To find it, look into the logs and search by the `instance` field found in the body. The logging category defaults to the fully qualified class name of the exception. By default, 4xx status codes are considered a problem of the client and are logged at `DEBUG` log level; 5xx status codes are a problem of the service, so they are logged at `ERROR`.

As a logging API, http://www.slf4j.org[slf4j] is used. Depending on your application server, you may also have to package a binding like `slf4j-jdk14`.

=== Annotations

Each of these defaults can optionally be overridden with annotations. Additionally, custom problem detail fields (called extensions) can be defined with `@Extension` annotated fields or methods.

[source,java]
---------------------------------------------------------------
@Type("https://example.com/probs/out-of-credit")
@Title("You do not have enough credit.")
@Status(FORBIDDEN) // <1>
@Logging(at = WARNING, to = "warnings") // <2>
@Getter @AllArgsConstructor @NoArgsConstructor(force = true) // <3>
public class OutOfCreditException extends RuntimeException {
    @Instance private URI instance; // <4>
    @Extension private int balance; // <5>
    private int cost; // <6>
    @Extension private List<URI> accounts; // <7>

    @Detail public String getDetail() { // <8>
        return "Your current balance is " + balance + ", but that costs " + cost + ".";
    }
}
---------------------------------------------------------------

<1> The status is a constant from the `javax.ws.rs.core.Response.Status` enum.
<2> The `@Logging` annotation can also be on the package (i.e. in the `package-info.java` file) to be a fallback for all exceptions in the package.
<3> These are https://projectlombok.org[Lombok] annotations, just for demo purposes; you can write the boiler plate code by hand, of course ;-)
<4> The `@Instance` annotation can be on a field or a no-arg method.
<5> There can be multiple `@Extension` annotations on fields or no-arg methods.
<6> This field is not annotated, so it won't be part of the body.
<7> Extensions can also be complex types, i.e. lists or maps or objects containing multiple fields, as long as they are (de)serializable by JSONB.
<8> The `@Detail` annotation can be on a field or a no-arg method.

This will result in an exception body similar to:

[source,json]
---------------------------------------------------------------
{
  "type": "https://example.com/probs/out-of-credit",
  "title": "Forbidden",
  "status": 403,
  "detail": "Your current balance is 30, but that costs 50.",
  "instance": "urn:uuid:d294b32b-9dda-4292-b51f-35f65b4bf64d",
  "balance": 50,
  "accounts": [
    "/account/12345",
    "/account/67890"
  ]
}
---------------------------------------------------------------


== Client Side Examples



== Spec & API

* MUST `application/problem+json`, `application/problem+xml`; SHOULD any, e.g. `+yaml`
* SHOULD render `text/html`
* map also `@Valid` REST params
* logging: 4xx = DEBUG, 5xx = ERROR; configurable?
* order of extensions is alphabetic (which is better for tests than random)
* multiple extensions with the same name: undefined behavior
* JAXB can't unmarshal a subclass with the same type and namespace
* Security considerations: nothing dangerous in problem details (i.e. exception message); stack-trace in logs

// TODO scan client classpath for @Type annotated exceptions (and document this in the spec and the annotation)
// TODO can we use the exact timestamp of the log for the response header timestamp?
// TODO inherited annotations
// TODO cause annotations
// TODO type factory, e.g. URL to OpenAPI
// TODO instance factory, e.g. URL to the logging system filtering on an UUID

== Package Structure

=== API

This is the API your application can depend on while the implementations can vary. It contains the annotations, an enum `LogLevel` for the `@Logging` annotation, and a `Constants` class containing `PROBLEM_DETAIL_JSON` and `PROBLEM_DETAIL_XML`, and their typed equivalents for JAX-RS `MediaType`.

On the server side, the binding happens without any application code dependencies, e.g. by an `ExceptionMapper`, a `ControllerAdvice`, or whatever mechanism is necessary for the implementation.

On the client side, some manual registration (e.g. of a `ClientResponseFilter` or a `ResponseErrorHandler` and the exceptions to be mapped to) may be necessary, but this will not be portable, as the mechanism to do this registration is specific to the http client api you use. Some implementations may even work without such a manual step.

=== Dummy-Impl [ri]

A JAX-RS implementation, called `ri` even though it's actually only a POC, and it's incomplete. See the README for details.

=== ri-spring

A Spring Boot implementation. This also is just a POC, there may be better integration points that I'm not aware of.

=== ri-lib

This is a library used by the JAX-RS RI as well as the Spring RI. It's not part of any supported public API, so you MUST NOT depend on this module directly.

=== Test (JAX-RS)

Builds a `war` hard-wired to the `ri`; and when using the maven profile `with-slf4j`, the `slf4j-api` and `slf4j-jdk14` are included as well. The integration tests use https://github.com/t1/jee-testcontainers[JEE Testcontainers], i.e. it can be configured to start different Docker containers with various JEE application servers (details below). By default, it starts a Wildfly.

You can also specify a base URL in the system property `testcontainer-running` (e.g. `-Dtestcontainer-running=http://localhost:8080/problem-details-test`), so the tests verify a running service. This is very handy while developing the implementation. This also works when the running service is the Spring Boot Test application (see below).

==== Wildfly

Default `mvn` or explicitly `mvn -Djee-testcontainer=wildfly`

==== Open Liberty

`mvn -Djee-testcontainer=open-liberty:19.0.0.9-javaee8-java11 -Pwith-slf4j`

Needs the tag for jdk11 support. Needs dependencies on `slf4j-api` and `slf4j-jdk14`.

==== TomEE

`mvn -Djee-testcontainer=tomee`

3 tests fail, because this version of TomEE (9.0.20 / 8.0.0-M3) doesn't write the problem detail response entity in some cases for some reason:
StandardExceptionMappingIT.shouldMapWebApplicationExceptionWithoutEntityButMessage
StandardExceptionMappingIT.shouldMapWebApplicationExceptionWithoutEntityOrMessage
ValidationFailedExceptionMappingIT.shouldMapValidationFailedException

==== Payara

`mvn -Djee-testcontainer=payara -Pwith-slf4j`

Currently fails due to lack of jdk11 support of the https://hub.docker.com/r/payara/server-full[`payara`] image. Needs dependencies on `slf4j-api` and `slf4j-jdk14`.

=== test-spring

Builds a Spring Boot application containing the RI. The integration tests also start the application.

You can specify a base URL in the system property `testcontainer-running` (e.g. `-Dtestcontainer-running=http://localhost:8080`), so the tests verify a running service. This is very handy while developing the implementation. This also works when the running service is the JAX-RS Test application (see above).
